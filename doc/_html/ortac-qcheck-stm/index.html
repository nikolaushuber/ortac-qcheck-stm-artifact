<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>index (ortac-qcheck-stm.index)</title><meta charset="utf-8"/><link rel="stylesheet" href="../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.2"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> – ortac-qcheck-stm</nav><header class="odoc-preamble"><h1 id="ortac/qcheck-stm"><a href="#ortac/qcheck-stm" class="anchor"></a>Ortac/QCheck-STM</h1></header><nav class="odoc-toc"><ul><li><a href="#overview">Overview</a></li><li><a href="#how-to-write-gospel-specifications?">How to write Gospel specifications?</a></li><li><a href="#how-to-configure-the-generated-tests?">How to configure the generated tests?</a></li><li><a href="#dependencies-of-the-generated-tests">Dependencies of the generated tests</a></li><li><a href="#warning-system">Warning system</a><ul><li><a href="#ortac/qcheck-stm-specifics">Ortac/QCheck-STM specifics</a></li><li><a href="#ortac-limitations"><code>ortac</code> limitations</a></li><li><a href="#other-limitations">Other limitations</a></li><li><a href="#returning-sut">Functions returning a SUT</a></li></ul></li><li><a href="#segmentation-faults-and-non-termination">Segmentation faults and non-termination</a></li></ul></nav><div class="odoc-content"><h2 id="overview"><a href="#overview" class="anchor"></a>Overview</h2><p>The <code>qcheck-stm</code> plugin for <code>ortac</code> (called Ortac/QCheck-STM in order to avoid ambiguities) generates a standalone executable using <a href="https://ocaml-multicore.github.io/multicoretests/">QCheck-STM</a> to perform model-based state-machine testing of a module, building up the model from its <a href="https://ocaml-gospel.github.io/gospel/">Gospel</a> specifications.</p><p>In order to be able to generate the STM module, the plugin will need five pieces of information:</p><ol><li>What type do we want to test? This is called <em>system under test</em> or <em>SUT</em> by QCheck-STM.</li><li>How to generate a value of this type? The <code>init_sut</code> function.</li><li>What is the model of this type? This is what is taken as the <em>state</em> by QCheck-STM.</li><li>How to generate the said model? The <code>init_state</code> function.</li><li>How does the model change when calling a function? The <code>next_state</code> function.</li></ol><p>Answering these five questions is done part in a configuration module and part in the Gospel specifications that we will have to write in a specific style.</p><p>This tutorial aims at showing how to write Gospel specifications for our modules in order to be able to automatically generate the QCheck-STM tests with the <code>ortac</code> command-line tool and its Ortac/QCheck-STM plugin.</p><p>We are going to build an example for a simple fixed-size container library.</p><h2 id="how-to-write-gospel-specifications?"><a href="#how-to-write-gospel-specifications?" class="anchor"></a>How to write Gospel specifications?</h2><p>In order to use the Ortac/QCheck-STM, the module we want to test must contain three kinds of items:</p><ol><li>The type declaration for <code>SUT</code></li><li>The function used to generate the initial value of <code>SUT</code></li><li>Functions to be tested</li></ol><p>Here is an example for the declaration of type <code>SUT</code>:</p><pre class="language-ocaml"><code>type 'a t
(*@ model size : int
    mutable model contents : 'a list *)</code></pre><p>we can see the Gospel specifications under the type declaration, in the special Gospel comments. These specifications give two models to the type, one non mutable and one mutable. These models are necessary (or at least some models) in order to give enough information to the <code>qcheck-stm</code> plugin to build the functional <em>state</em> that QCheck-STM will be using. This item is then bringing two needed pieces of information: what are the type of the <code>SUT</code> and the type of the <code>state</code>.</p><p>The second item is the function used for generating the inital value for <code>SUT</code>. Here again, this item will bring two needed pieces of information: how to build the initial value of <code>SUT</code> and the corresponding <code>state</code>. This is the role of the <code>make</code> function along with its specification.</p><pre class="language-ocaml"><code>val make : int -&gt; 'a -&gt; 'a t
(*@ t = make i a
    checks i &gt;= 0
    ensures t.size = i
    ensures t.contents = List.init i (fun j -&gt; a) *)</code></pre><p>Obviously, the function should return a value of type <code>SUT</code>. But more importantly, the specification has to give a value to each of the models that were given to the type <code>SUT</code> in its specification. Here, this means we need to give a value to <code>t.size</code> and to <code>t.contents</code>. The <code>checks</code> clause is part of the Gospel specification of the function, but it won't be used by the plugin to generate any code. We can give more information that the plugin needs, for example if we are also using another tool based on Gospel specifications. The plugin will simply ignore them.</p><p>Now that Ortac/QCheck-STM is able to generate an initial value for the type under test and its model, we can turn our attention to the functions we will want to test. Here is the example of the classic <code>set</code> function along with its Gospel specification written with the <code>qcheck-stm</code> ortac plugin in mind:</p><pre class="language-ocaml"><code>val set : 'a t -&gt; int -&gt; 'a -&gt; unit
(*@ set t i a
    checks 0 &lt;= i &lt; t.size
    modifies t.contents
    ensures t.contents = List.mapi (fun j x -&gt; if j = (i : integer) then a else x) (old t.contents) *)</code></pre><p>The most important purpose of the specifications (in the context of this tutorial) is to bring the last piece of information. That is to answer the question about how the model changes when calling the specified function. This is done in two steps.</p><p>First, we have to declare which of the model's field are modified in the <code>modifies</code> clause. Let's note that if, like in the case of the <code>set</code> function, the function is returning <code>unit</code>, it is a Gospel error to not give any <code>modifies</code> clause. But Gospel lets us write <code>modifies ()</code> in order to express the fact that the function is modifying something that is not in the model of any of the argument. However, Ortac/QCheck-STM will read the <code>modifies</code> clauses (if any) in order to determine which model's fields are modified when the function is called. The model's fields that don't appear in any of the <code>modifies</code> clauses will be considered as not modified.</p><p>Then, the plugin will look at the <code>ensures</code> clauses (the postconditions) in order to find one clause per modified field that expresses how to compute the modification. For now, the tool is not very smart. The basic rule of thumb is that we need to write down a computable description of the new model's field as a function of the old one. This will often mean that we need to write stronger postconditions that what would be necessary in another context. If the plugin can't find any suitable <code>ensures</code> clause, it will raise a warning and skip the function for test.</p><p>We can see again the <code>checks</code> clause. This time, as the function is a candidate for test, the <code>checks</code> clause will be used by the tool to check that if the condition of the clause is not respected, the function raises the <code>Invalid_arg</code> exception.</p><p>Now that the <code>set</code> function is ready to be tested, let's turn our attention to another example. Here is the example of the <code>get</code> function along with its Gospel specifications:</p><pre class="language-ocaml"><code>val get : 'a t -&gt; int -&gt; 'a
(*@ a = get t i
    checks 0 &lt;= i &lt; t.size
    ensures a = List.nth t.contents i *)</code></pre><p>Here, the <code>ensures</code> clause has another use. As the <code>get</code> function does not modifies anything, there is no need to give the values of the model’s fields after the function. Note that the <code>ensures</code> clause wouldn't have been fit for this purpose anyway. The <code>ensures</code> clauses that are not used for the <code>next_state</code> function are used for checking postconditions, here a postcondition stating a relation between the returned value and the function arguments. These <code>ensures</code> clauses are not necessary to generate the QCheck-STM tests, but they will bring strength to our tests.</p><p>In order to generate postcondition-checking, Ortac/QCheck-STM uses the <code>ensures</code> clauses that were not used for the <code>next_state</code> function but it also uses the <code>checks</code> clauses and the <code>raises</code> ones.</p><h2 id="how-to-configure-the-generated-tests?"><a href="#how-to-configure-the-generated-tests?" class="anchor"></a>How to configure the generated tests?</h2><p>Now we need a configuration file. Configuration files for Ortac/QCheck-STM are OCaml modules containing <em>at least</em> a type declaration for `sut` (usually the type `t` of the module under test with all the type parameters instantiated) and a value declaration for `init_sut` (a call to a function from the module under test returning a value of type `sut`)</p><pre class="language-ocaml"><code>open Example

type sut = char t

let init_sut = make 42 'a'</code></pre><p>Then, we can generate the QCheck-STM file by running the following command where we indicate the file we want to test and the configuration file. We can write the generated code into a file, using the <code>-o</code> option.</p><pre class="language-sh"><code>$ ortac qcheck-stm example.mli example_config.ml -o stm_example.ml</code></pre><p>The other information we can put in the configuration file are:</p><ul><li>custom <code>QCheck</code> generators in a <code>Gen</code> module</li><li>custom <code>STM</code> printers in a <code>Pp</code> module</li><li>custom <code>STM.ty</code> extensions and its functional constructors in a <code>Ty</code> module</li></ul><p>These additional information are mostly necessary when the tested library exposes other types than the one used as SUT.</p><p>The <code>Gen</code> module should contain a <code>QCheck.Gen.t</code> for each of these types. It is also possible to shadow already defined generators. One use case for this last possibility is to limit the size of the generated integers.</p><p>As explained in the <code>returning-sut</code> section, integers as argument of a function returning a SUT are generated with <code>QCheck.Gen.small_signed_int</code>. When we want to customize the generation of those arguments, we need to overwrite this generator.</p><p>The <code>Pp</code> module should contain a <code>Util.Pp.t</code> for each of these types. These values are used to print the runnable scenario if the test fails. We can refer to the <a href="https://ocaml-multicore.github.io/multicoretests/dev/qcheck-multicoretests-util/Util/Pp/index.html">module documentation</a> for more details.</p><p>The <code>Ty</code> module should contain an <code>STM.ty</code> extension and a corresponding <code>STM.ty_show</code> smart constructor for each of these types. An <code>'a STM.ty_show</code> is a pair of an <code>'a ty</code> value and an <code>'a -&gt; string</code> function.</p><h2 id="dependencies-of-the-generated-tests"><a href="#dependencies-of-the-generated-tests" class="anchor"></a>Dependencies of the generated tests</h2><p>The generated OCaml file has a bunch of dependencies:</p><ul><li><code>qcheck-core</code></li><li><code>qcheck-core.runner</code></li><li><code>qcheck-stm.stm</code></li><li><code>qcheck-stm.sequential</code></li><li><code>qckeck-multicoretests-util</code></li><li><code>ortac-runtime</code></li></ul><p>Using the dune build system, our dune rule for the example above would look like the following:</p><pre class="language-dune"><code>(test
 (name stm_example)
 (libraries
  qcheck-core
  qcheck-core.runner
  qcheck-stm.stm
  qcheck-stm.sequential
  qcheck-multicoretests-util
  ortac-runtime
  example)
 (action
  (run %{test} --verbose)))</code></pre><h2 id="warning-system"><a href="#warning-system" class="anchor"></a>Warning system</h2><p>Now that we know what Gospel specifications for the <code>qcheck-stm</code> plugin should look like and how to generate the QCheck-STM file, let's focus on what can go wrong. The <code>qcheck-stm</code> plugin has an extensive set of warnings to help us formulate our specifications in a way it can use.</p><p>Most of the time, Ortac/QCheck-STM will skip a function if it can't generate one of the elements needed by QCheck-STM. Doing so, it will display a warning on <code>stderr</code> in order for us to be able to get an idea about test coverage.</p><h3 id="ortac/qcheck-stm-specifics"><a href="#ortac/qcheck-stm-specifics" class="anchor"></a>Ortac/QCheck-STM specifics</h3><p>Let's start with the warnings specific to the plugin.</p><p>The principle at the core of Ortac/QCheck-STM is to turn the Gospel specifications into OCaml code needed by the QCheck-STM test framework. This means that we need to provide these pieces of information into the specification in a style that allows the plugin to understand them.</p><p>The most delicate piece of information we have to give is how the function modifies the model of the <code>SUT</code>. As stated above, the plugin is looking for this information in the <code>ensures</code> clauses.</p><p>If Ortac/QCheck-STM doesn't have enough information in the specifications in order to compute the next value for every model's field appearing in a <code>modifies</code> clause, it won't be able to test the function and inform us with a warning.</p><p>For example, the following specifications are not enough for Ortac/QCheck-STM.</p><pre class="language-ocaml"><code>val ensures_not_found_for_next_state : 'a t -&gt; unit
(*@ ensures_not_found_for_next_state t
    modifies t.contents
    ensures List.length t.contents = List.length (old t.contents) *)</code></pre><p>Ortac/QCheck-STM will look at the <code>modifies</code> clause and then look for an <code>ensures</code> clause for each of the modified models that allows to compute its new value. Here, it won't find any and warn us with the following message:</p><pre class="language-sh"><code>$ ortac qcheck-stm example_next_state.mli example_config.ml -o foo.ml
File &quot;example_next_state.mli&quot;, line 15, characters 13-23:
15 |     modifies t.contents
                  ^^^^^^^^^^
Warning: Skipping ensures_not_found_for_next_state: model contents is
         declared as modified by the function but no suitable ensures clause
         was found. Specifications should contain at least one &quot;ensures
         x.contents = expr&quot; where x is the SUT and expr can refer to the SUT
         only under an old operator and can't refer to the returned value.</code></pre><p>That doesn't mean that we have to rewrite the clause. Maybe it contains information we still want to state in the specifications. You can then add another <code>ensures</code> clause with the relevant information in order to compute the new value of the modified model. The warning message gives us the form in which the plugin expects to find the information, namely a description of the new state by an expression in which any reference to the state should be to the old state (that is the state before the function is called).</p><p>Note also that if we write <code>modifies t</code>, the plugin assumes that all the mutable fields are modified and will try to find a description for all of them. So we'll need to avoid being too general in the modifies clauses.</p><p>In Gospel, we have the possibility to use ghost values, as arguments and/or as returned values. As those values don’t exist in the actual code that will be called during the test, Ortac/QCheck-STM doesn't support Gospel specifications with ghost values in the header.</p><p>If we add the following declaration to our example file,</p><pre class="language-ocaml"><code>val ghost_arg : char -&gt; 'a t -&gt; bool
(*@ b = ghost_arg [ i : integer] c t *)</code></pre><p>the command will generate the following warning:</p><pre class="language-sh"><code>$ ortac qcheck-stm example_ghost.mli example_config.ml -o foo.ml
File &quot;example_ghost.mli&quot;, line 18, characters 20-21:
18 | (*@ b = ghost_arg [ i : integer] c t *)
                         ^
Warning: Skipping ghost_arg: functions with a ghost argument are not
         supported.</code></pre><p>You'll need to write the specifications without using <code>ghost</code> arguments or returned value if we want to test this function with Ortac/QCheck-STM.</p><p>Finally, when we want to test a library with a parameterized type, we need to instantiate the type parameter in order to generate the QCheck-STM tests. Choosing the right instantiation implies to be careful when the library contains specialized functions.</p><p>For example, if we add the following declaration to our example file,</p><pre class="language-ocaml"><code>val incompatible_type : char -&gt; string t -&gt; bool
(*@ b = incompatible_type c t *)</code></pre><p>the plugin will generate a warning for this function and skip it.</p><pre class="language-sh"><code>$ ortac qcheck-stm example_incompatible_type.mli example_config.ml -o foo.ml
File &quot;example_incompatible_type.mli&quot;, line 17, characters 32-40:
17 | val incompatible_type : char -&gt; string t -&gt; bool
                                     ^^^^^^^^
Warning: Skipping incompatible_type: the type of its SUT-type argument is
         incompatible with the configured SUT type: char t.</code></pre><p>In the case we have functions specialized with different instantiations, we can always generate one test per possible instantiation, of course.</p><h3 id="ortac-limitations"><a href="#ortac-limitations" class="anchor"></a><code>ortac</code> limitations</h3><p>The second source of limitations is the <code>ocaml_of_gospel</code> translation provided by the <code>ortac-core</code> package. Gospel being a logical language, it is not fully executable. <code>ortac-core</code> identifies an executable subset of Gospel and translates it to OCaml. But there are still some limitations, in particular concerning quantification. For now, only well-bounded quantifications over integers are supported.</p><p>If we add the following declaration to our example file,</p><pre class="language-ocaml"><code>val unsupported_quantification : 'a t -&gt; bool
(*@ b = unsupported_quantification t
    ensures b = forall a. List.mem a t.contents -&gt; a = a *)</code></pre><p>the command will generate the following warning:</p><pre class="language-sh"><code>$ ortac qcheck-stm example_ill_formed_quantification.mli example_config.ml -o foo.ml
File &quot;example_ill_formed_quantification.mli&quot;, line 13, characters 0-142:
13 | val unsupported_quantification : 'a t -&gt; bool
14 | (*@ b = unsupported_quantification t
15 |     ensures b = forall a. List.mem a t.contents -&gt; a = a *)
Warning: Incomplete computation of the returned value in the specification of unsupported_quantification. Failure message won't be able to display the expected returned value.
File &quot;example_ill_formed_quantification.mli&quot;, line 15, characters 16-56:
15 |     ensures b = forall a. List.mem a t.contents -&gt; a = a *)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning: Skipping clause: unsupported quantification.</code></pre><p>Note that only the clause involving the unsupported quantification has not been translated. If the function's specification contains other clauses that can be translated and contain enough information for the plugin to do its job, then we will be able to test the function. If not, maybe we can rewrite the clause without involving this sort of quantification. In this particular example, we can use the <code>List.for_all</code> combinator from the Gospel standard library <code>List</code> module:</p><pre class="language-ocaml"><code>val for_all : 'a t -&gt; bool
(*@ b = for_all t
    ensures b = List.for_all (fun x -&gt; x = x) t.contents *)</code></pre><h3 id="other-limitations"><a href="#other-limitations" class="anchor"></a>Other limitations</h3><p>Finally, note that this tool is still fairly new and comes with limitations that should be lifted in the future. Fow now, we only support tuples with less than 10 elements and we only support first-order functions.</p><p>If we add the following declarations to our example file,</p><pre class="language-ocaml"><code>val of_list : 'a list -&gt; 'a t
(*@ t = of_list xs *)

val g : 'a t -&gt; 'a * 'a * 'a * 'a * 'a * 'a * 'a * 'a * 'a * 'a -&gt; bool
(*@ b = g t x *)

val for_all : ('a -&gt; bool) -&gt; 'a t -&gt; bool
(*@ b = for_all p t *)</code></pre><p>Ortac/QCheck-STM will generate the following warnings:</p><pre class="language-sh"><code>$ ortac qcheck-stm example_limitations.mli example_config.ml -o foo.ml
File &quot;example_limitations.mli&quot;, line 18, characters 3-19:
18 | (*@ t = of_list xs *)
        ^^^^^^^^^^^^^^^^
Warning: Skipping of_list: the specification of the function does not specify
         all fields of the model for the returned SUT value. Specifications
         should contain at least one &quot;ensures x.size = expr&quot; and
         &quot;ensures x.contents = expr&quot; where x is the returned SUT and expr can
         refer to other SUTs only under an old operator.
File &quot;example_limitations.mli&quot;, line 20, characters 16-63:
20 | val g : 'a t -&gt; 'a * 'a * 'a * 'a * 'a * 'a * 'a * 'a * 'a * 'a -&gt; bool
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Warning: Skipping g: Can only test tuples with arity &lt; 10.
File &quot;example_limitations.mli&quot;, line 23, characters 15-25:
23 | val for_all : ('a -&gt; bool) -&gt; 'a t -&gt; bool
                    ^^^^^^^^^^
Warning: Skipping for_all: functions are not supported yet as arguments.</code></pre><h3 id="returning-sut"><a href="#returning-sut" class="anchor"></a>Functions returning a SUT</h3><p>Functions returning a SUT will be tested, however, there are some restrictions and peculiarities:</p><ul><li>Only functions returning a single SUT value are tested, if the SUT is nested inside another structure (e.g., a tuple or a list) the function will be skipped</li><li>Many <code>init</code>/<code>create</code> like functions take an integer relating to the initial size of the datastructure as an argument. In order to keep the size of the created data structure manageable, a heuristic is used. Whenever a functions returns a SUT, but does not take a SUT as an input argument, any <code>Gen.int</code> generators in <code>Spec.arb_cmd</code> are automatically exchanged with <code>Gen.small_signed_int</code></li></ul><h2 id="segmentation-faults-and-non-termination"><a href="#segmentation-faults-and-non-termination" class="anchor"></a>Segmentation faults and non-termination</h2><p>In the standard configuration, the code generated by the <code>qcheck-stm</code> plugin will run a number of tests in sequence in the same process. If one of those test runs crashes (e.g. by incorrectly using <code>Obj.magic</code>), this automatically also kills the overall process, therefore no trace can be shown to the user of which series of commands lead to the crashing scenario. Similarily, if one of the functions under test does not return, the overall test suite is stalled indefinitely.</p><p>It is possible to instruct the underlying runtime to instead run all tests in separate processes with a given timeout, so that in case of a segmentation fault the runtime can still recover a trace leading to said crash, and non-terminating computations are automatically stopped after the given timeout has passed.</p><p>This is done by setting the environment variable <code>ORTAC_QCHECK_STM_TIMEOUT</code> to a timeout value in seconds, after which the runtime will automatically kill the process running the test.</p><p>For example when using dune to run the test, this can be achieved in the following way:</p><pre class="language-dune"><code>(test
 (name stm_example)
 (libraries
  qcheck-core
  qcheck-core.runner
  qcheck-stm.stm
  qcheck-stm.sequential
  qcheck-multicoretests-util
  ortac-runtime
  example)
 (action
  (setenv
   ORTAC_QCHECK_STM_TIMEOUT
   10
    (run %{test} --verbose)))</code></pre><p>This would automatically end each test after 10 seconds.</p><p>Instead of setting the timeout permanently in the dune file, one can also set the environment variable when running tests from the command-line:</p><pre class="language-sh"><code>$ ORTAC_QCHECK_STM_TIMEOUT=10 dune runtest</code></pre></div></body></html>
