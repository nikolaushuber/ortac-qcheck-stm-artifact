<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Gospelstdlib (gospel.Gospelstdlib)</title><link rel="stylesheet" href="../../_odoc-theme/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc v2.3.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">gospel</a> &#x00BB; Gospelstdlib</nav><header class="odoc-preamble"><h1>Module <code><span>Gospelstdlib</span></code></h1><p>This file contains the Gospel standard library.</p></header><nav class="odoc-toc"><ul><li><a href="#arithmetic">Arithmetic</a><ul><li><a href="#comparisons">Comparisons</a></li><li><a href="#bitwise-operations">Bitwise operations</a></li><li><a href="#machine-integers">Machine integers</a></li></ul></li><li><a href="#couples">Couples</a></li><li><a href="#references">References</a></li><li><a href="#sequences">Sequences</a></li><li><a href="#arrays">Arrays</a></li><li><a href="#bags">Bags</a></li><li><a href="#sets">Sets</a></li></ul></nav><div class="odoc-content"><p>The following are not defined in the Gospelstdlib but are built-in in Gospel:</p><ul><li><code>type unit</code></li><li><code>type string</code></li><li><code>type char</code></li><li><code>type float</code></li><li><code>type bool</code></li><li><code>type integer</code></li><li><code>type int</code></li></ul><ul><li><code>type 'a option</code></li><li><code>function None: 'a option</code></li><li><code>function Some (x: 'a) : 'a option</code></li></ul><ul><li><code>type 'a list</code></li><li><code>function ([]): 'a list</code></li><li><code>function (::) (x: 'a) (l: 'a list) : 'a list</code></li></ul><ul><li><code>predicate (=) (x y: 'a)</code></li></ul><p>The rest of this module is the actual content of the Gospel module <code>Gospelstdlib</code>. This module is automatically opened in Gospel specifications.</p><pre class="language-gospel"><code>Gospel declaration:
    type 'a sequence </code></pre><p>The type for finite sequences.</p><pre class="language-gospel"><code>Gospel declaration:
    type 'a bag </code></pre><p>The type for finite unordered multisets.</p><pre class="language-gospel"><code>Gospel declaration:
    type 'a ref </code></pre><p>The type for references.</p><pre class="language-gospel"><code>Gospel declaration:
    type 'a set </code></pre><p>The type for finite unordered sets.</p><h2 id="arithmetic"><a href="#arithmetic" class="anchor"></a>Arithmetic</h2><p>The type <code>integer</code> is built-in. This is the type of arbitrary precision integers, not to be confused with OCaml's type <code>int</code> (machine, bounded integers).</p><pre class="language-gospel"><code>Gospel declaration:
    function succ (x: integer) : integer </code></pre><pre class="language-gospel"><code>Gospel declaration:
    function pred (x: integer) : integer </code></pre><pre class="language-gospel"><code>Gospel declaration:
    function (-_) (x: integer) : integer </code></pre><pre class="language-gospel"><code>Gospel declaration:
    function (+) (x y: integer) : integer </code></pre><pre class="language-gospel"><code>Gospel declaration:
    function (-) (x y: integer) : integer </code></pre><pre class="language-gospel"><code>Gospel declaration:
    function ( * ) (x y: integer) : integer </code></pre><pre class="language-gospel"><code>Gospel declaration:
    function (/) (x y: integer) : integer </code></pre><pre class="language-gospel"><code>Gospel declaration:
    function mod (x y: integer) : integer </code></pre><pre class="language-gospel"><code>Gospel declaration:
    function pow (x y: integer) : integer </code></pre><pre class="language-gospel"><code>Gospel declaration:
    function abs (x:integer) : integer </code></pre><pre class="language-gospel"><code>Gospel declaration:
    function min (x y : integer) : integer </code></pre><pre class="language-gospel"><code>Gospel declaration:
    function max (x y : integer) : integer </code></pre><h3 id="comparisons"><a href="#comparisons" class="anchor"></a>Comparisons</h3><pre class="language-gospel"><code>Gospel declaration:
    predicate (&gt;) (x y: integer) </code></pre><pre class="language-gospel"><code>Gospel declaration:
    predicate (&gt;=) (x y: integer) </code></pre><pre class="language-gospel"><code>Gospel declaration:
    predicate (&lt;) (x y: integer) </code></pre><pre class="language-gospel"><code>Gospel declaration:
    predicate (&lt;=) (x y: integer) </code></pre><h3 id="bitwise-operations"><a href="#bitwise-operations" class="anchor"></a>Bitwise operations</h3><pre class="language-gospel"><code>Gospel declaration:
    function logand (x y: integer) : integer </code></pre><pre class="language-gospel"><code>Gospel declaration:
    function logor (x y: integer) : integer </code></pre><pre class="language-gospel"><code>Gospel declaration:
    function logxor (x y: integer) : integer </code></pre><pre class="language-gospel"><code>Gospel declaration:
    function lognot (x: integer) : integer </code></pre><pre class="language-gospel"><code>Gospel declaration:
    function shift_left (x y: integer) : integer </code></pre><p>Shifts to the left, equivalent to a multiplication by a power of two</p><pre class="language-gospel"><code>Gospel declaration:
    function shift_right (x y: integer) : integer </code></pre><p>Shifts to the right, equivalent to a multiplication by a power of two with rounding toward -oo</p><pre class="language-gospel"><code>Gospel declaration:
    function shift_right_trunc (x y: integer) : integer </code></pre><p>Shift to the right with truncation, equivalent to a multiplication by a power of two with rounding toward 0</p><h3 id="machine-integers"><a href="#machine-integers" class="anchor"></a>Machine integers</h3><p>There is a coercion from type <code>int</code> to type <code>integer</code>, so that Gospel specifications can be written using type <code>integer</code> only, and yet use OCaml's variables of type <code>int</code>. The Gospel typechecker will automatically apply <code>integer_of_int</code> whenever necessary.</p><pre class="language-gospel"><code>Gospel declaration:
    function integer_of_int (x: int) : integer 
    coercion </code></pre><pre class="language-gospel"><code>Gospel declaration:
    function max_int : integer </code></pre><pre class="language-gospel"><code>Gospel declaration:
    function min_int : integer </code></pre><h2 id="couples"><a href="#couples" class="anchor"></a>Couples</h2><pre class="language-gospel"><code>Gospel declaration:
    function fst (p: 'a * 'b) : 'a </code></pre><p><code>fst (x, y)</code> is <code>x</code>.</p><pre class="language-gospel"><code>Gospel declaration:
    function snd (p: 'a * 'b) : 'b </code></pre><p><code>snd (x, y)</code> is <code>y</code>.</p><h2 id="references"><a href="#references" class="anchor"></a>References</h2><pre class="language-gospel"><code>Gospel declaration:
    function (!_) (r: 'a ref) : 'a </code></pre><p>Reference content access operator.</p><h2 id="sequences"><a href="#sequences" class="anchor"></a>Sequences</h2><pre class="language-gospel"><code>Gospel declaration:
    function (++) (s s': 'a sequence) : 'a sequence </code></pre><p><code>s ++ s'</code> is the sequence <code>s</code> followed by the sequence <code>s'</code>.</p><pre class="language-gospel"><code>Gospel declaration:
    function ([_]) (s: 'a sequence) (i: integer): 'a </code></pre><p><code>s[i]</code> is the <code>i</code>th element of the sequence <code>s</code>.</p><pre class="language-gospel"><code>Gospel declaration:
    function ([_.._]) (s: 'a sequence) (i1: integer) (i2: integer): 'a sequence </code></pre><pre class="language-gospel"><code>Gospel declaration:
    function ([_..]) (s: 'a sequence) (i: integer): 'a sequence </code></pre><pre class="language-gospel"><code>Gospel declaration:
    function ([.._]) (s: 'a sequence) (i: integer): 'a sequence </code></pre><div class="odoc-spec"><div class="spec module anchored" id="module-Sequence"><a href="#module-Sequence" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Sequence/index.html">Sequence</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><p>Lists</p><p>The type <code>'a list</code> and the constructors <code>[]</code> and <code>(::)</code> are built-in.</p><div class="odoc-spec"><div class="spec module anchored" id="module-List"><a href="#module-List" class="anchor"></a><code><span><span class="keyword">module</span> <a href="List/index.html">List</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><h2 id="arrays"><a href="#arrays" class="anchor"></a>Arrays</h2><div class="odoc-spec"><div class="spec module anchored" id="module-Array"><a href="#module-Array" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Array/index.html">Array</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><h2 id="bags"><a href="#bags" class="anchor"></a>Bags</h2><div class="odoc-spec"><div class="spec module anchored" id="module-Bag"><a href="#module-Bag" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Bag/index.html">Bag</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><h2 id="sets"><a href="#sets" class="anchor"></a>Sets</h2><pre class="language-gospel"><code>Gospel declaration:
    function ({}) : 'a set </code></pre><p><code>{}</code> is the empty set.</p><div class="odoc-spec"><div class="spec module anchored" id="module-Set"><a href="#module-Set" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Set/index.html">Set</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><pre class="language-gospel"><code>Gospel declaration:
    function ( [-&gt;] ) (f: 'a -&gt; 'b) (x:'a) (y: 'b) : 'a -&gt; 'b </code></pre><div class="odoc-spec"><div class="spec module anchored" id="module-Map"><a href="#module-Map" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Map/index.html">Map</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Maps from keys of type <code>'a</code> to values of type <code>'b</code> are represented by Gospel functions of type <code>'a -&gt; 'b</code>.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Order"><a href="#module-Order" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Order/index.html">Order</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><p>Other OCaml built-in stuff</p><div class="odoc-spec"><div class="spec exception anchored" id="exception-Not_found"><a href="#exception-Not_found" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Not_found</span></span></code></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Invalid_argument"><a href="#exception-Invalid_argument" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Invalid_argument</span> <span class="keyword">of</span> string</span></code></div></div><div class="odoc-spec"><div class="spec exception anchored" id="exception-Failure"><a href="#exception-Failure" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Failure</span> <span class="keyword">of</span> string</span></code></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Sys"><a href="#module-Sys" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Sys/index.html">Sys</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div></div></body></html>
